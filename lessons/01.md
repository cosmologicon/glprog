# Lesson 01

Starting WebGL
==============

You don't need a lot to start up WebGL. You'll need an HTML5 canvas element, which you can write
into your markup, or create one with `document.createElement`. Then you call
`canvas.getContext("webgl")`. If it works, this returns a WebGL context object, which you should
call `gl`.

	var gl = canvas.getContext("webgl")

This is similar to how you create a 2d context, except the argument is `"webgl"` instead of `"2d"`.

You can have more than one canvas, each with its own WebGL context, and draw to each one, but you
can't have more than one context on a single canvas. You also can't have a 2d context on the same
canvas as a WebGL context.

You can set up a WebGL context on a canvas that's not attached to the document. But WebGL is allowed
to not execute drawing commands that don't actually appear on screen, so there's not much of a
point.

The canvas object
=================

You don't need to keep a reference to the canvas itself. You can always refer to it as `gl.canvas`,
in case you want to style it. One thing you're likely to want to do is resize it. This is as easy
as:

	gl.canvas.width = 854
	gl.canvas.height = 480
	gl.viewport(0, 0, 854, 480)

You can resize it whenever you want. Just make sure to include the call to `gl.viewport` again.
I'll refer to the canvas as the "viewport" from now on. I don't know if that's the correct term, but
it sounds right to me.

This introduces the first of many coordinate systems, viewport coordinates. This is a coordinate
system with the origin at the bottom left of the viewport, with units in pixels. Thus the upper
right corner of the viewport, in our case, has viewport coordinates of (854, 480).

![viewport coordinates](/lessons/img/viewport-coordinates.png?raw=true "viewport run from (0,0) in the lower left to (854, 480) in the upper right")

This is different from HTML5 2d drawing context, where (0, 0) is in the upper left.

`gl.clear`
==========

There are only two ways to actually draw something in WebGL. One is `gl.clear`, and one is
`gl.drawArrays` or `gl.drawElements`. There are of course a bunch of other methods you'll need to
call, but the viewport won't actually change until you call one of these.

`gl.clear` is pretty simple - it sets the entire viewport to some color. Typically this is done at
the beginning of every frame of your game or animation, to start with a clean slate. The way you
should call `gl.clear` is like this:

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

You don't need `gl.DEPTH_BUFFER_BIT` in there if you're not using the depth buffer, which we're not
yet, but it doesn't hurt to get in the habit of clearing the depth buffer as well. We'll be
discussing depth in lesson 04. But you can just clear the color buffer if you prefer for now.

Setting the clear color
=======================

Colors in WebGL are represented by 4 values that range from 0 to 1, corresponding to the red, green,
blue, and alpha channels. This is similar to CSS colors like `rgba(255, 127, 0, 1)`, except the
range is 0 to 1 instead of 0 to 255. (If you're not familiar with the idea of treating colors as
sets of rgba components, you should probably learn it, as it's the only way to deal with colors in
WebGL.) Sometimes WebGL converts between the two ranges, like when you upload a texture, but when
you just specify a color, it will generally use values 0 to 1.

	gl.clearColor(0, 0, 0, 1)

This sets the clear color to solid (opaque) black. The default is transparent black (0, 0, 0, 0).
For reasons I'll cover in lesson 04, I recommend always setting the alpha value of the clear color
to 1 in WebGL. After calling `gl.clearColor`, any calls to `gl.clear` will use the specified color.

Scissor testing
===============

The scissor test lets you update part of the viewport while leaving the rest unchanged. If you
were to draw a shape, only the part of the shape that falls within the scissor region (i.e. the part
that passes the scissor test) would appear. This is similar to the HTML5 2d drawing context method
`clip`, except it only lets you clip within a rectangular region.

	gl.enable(gl.SCISSOR_TEST)
	gl.scissor(x, y, w, h)

Scissor testing is disabled by default, so you need to enable it with `gl.enable` before it will
work. You also need to set the scissor region you want to clip within. The scissor region is in
viewport coordinates. (x,y) is the lower left corner of the scissor box in pixels, and (w,h) is the
scissor box size in pixels.

![scissor region](/lessons/img/scissor-region.png?raw=true "when scissor testing is enabled, objects drawn are clipped to the scissor region")

To disable the scissor test, use:

	gl.disable(gl.SCISSOR_TEST)

In Lesson 01, we use the scissor test along with `gl.clear` to draw rectangles of a solid color.
Scissor testing can be occasionally useful, but we're rarely going to use it.

Getters used in this lesson
===========================

	// Number: viewport width in pixels
	gl.drawingBufferWidth
	// Number: viewport height in pixels
	gl.drawingBufferHeight
	// Array of 4 Numbers: [x, y, w, h] of the viewport box
	gl.getParameter(gl.VIEWPORT)
	// Array of 4 Numbers: [r, g, b, a] of the clear color
	gl.getParameter(gl.COLOR_CLEAR_VALUE)
	// boolean: whether scissor test is enabled
	gl.getParameter(gl.SCISSOR_TEST)
	// Array of 4 Numbers: [x, y, w, h] of the scissor region
	gl.getParameter(gl.SCISSOR_BOX)

Exercises
=========

1. What number is `gl.COLOR_BUFFER_BIT` equal to?
1. What `gl` enum is equal to `4354`? Hint: `for (var s in gl)`.
1. Change the background to a brighter or darker shade of blue.
1. Move the red box so that it's a few pixels away from the upper right corner.
1. Resize the yellow box so that it's twice as tall as it is wide.
1. Change the yellow box to purple.
1. Resize the viewport to 100x100 and draw a red box inside it.
1. Add a CSS border to the canvas with `gl.canvas.style.border`.
1. Create a second viewport and clear it to black, then clear the first viewport to orange.

