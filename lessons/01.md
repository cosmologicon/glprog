# Lesson 01

Starting WebGL
==============

To start WebGL, you'll need an HTML5 canvas element, which you can write into your markup, or create
one with `document.createElement`. Then you call `canvas.getContext("webgl")`. If it works, this
returns a WebGL context object, which you should call `gl`.

	var gl = canvas.getContext("webgl")

If it fails, `gl` will be `null`. This is similar to how you create a 2d context, except the
argument is `"webgl"` instead of `"2d"`.

You can have more than one canvas, each with its own WebGL context, and draw to each one, but you
can't have more than one context on a single canvas. You also can't have a 2d context on the same
canvas as a WebGL context.

You can set up a WebGL context on a canvas that's not attached to the document. But WebGL is allowed
to not execute drawing commands that don't actually appear on screen, so there's not much of a
point.

The viewport
============

You don't need to keep a reference to the canvas itself. You can always refer to it as `gl.canvas`,
in case you want to style it. One thing you're likely to want to do is resize it. This is as easy
as:

	gl.canvas.width = 854
	gl.canvas.height = 480
	gl.viewport(0, 0, 854, 480)

You can resize it whenever you want. Just make sure to include the call to `gl.viewport` again.
I'll refer to the canvas as the "viewport" from now on. I don't know if that's the correct term, but
it sounds right to me.

This introduces the first of many coordinate systems, viewport coordinates. This is a coordinate
system with the origin at the bottom left of the viewport, with units in pixels. Thus the upper
right corner of the viewport, in our case, has viewport coordinates of (854, 480).

![viewport coordinates](/lessons/img/viewport-coordinates.png?raw=true "viewport run from (0,0) in the lower left to (854, 480) in the upper right")

This is different from HTML5 2d drawing context, where (0, 0) is in the upper left.

WebGL state
===========

You can think of WebGL having a complicated state defined by a bunch of variables whose values you
set from JavaScript. You can also get the value of these variables from WebGL, although it's not
always obvious how. The values of the variables in this state when a drawing command is issued
determine what the command actually does, which determines how the viewport is actually changed.

![flow diagram: state](/lessons/img/flow-diagram-state.png?raw=true "the WebGL state is accessed via getters and setters")

The 4-element viewport box is part of the WebGL state, and `gl.viewport` is its setter (the method
you call to set its value). The corresponding getter (the method you call to get its value) is:

	gl.getParameter(gl.VIEWPORT)

In WebGL, getters begin with the prefix "get", and setters have no prefix. This is different from
most APIs, in which it's more common for setters to have a prefix than getters. I suspect that the
reason for this is because you use setters far more often than getters. Some people recommend
avoiding getters altogether: if you need to know a piece of the WebGL state, keep a copy of it in
JavaScript, that you update whenever you call the setter. I'm not going to bother doing that, but in
principle you can. At any rate, it's true that you'll be calling setters far more often.
`gl.getParameter` is the most general-purpose getter, which we'll see a lot.

In these lessons, I'll use the relevant getters for illustration purposes, writing the results to
`console.log`. I'm not going to bother explaining each one. I'll just list them in a section called
"Getters used in this lesson" at the end.

Why do you have to call `gl.getParameter(gl.VIEWPORT)`? Why isn't the method just called
`gl.getViewport()`? I have no idea, but you should understand what's going on here. `gl.VIEWPORT` is
the first of many, many GLenum ("enum" as in "enumeration") values that we'll encounter. You will
recognize them by their all-caps names. These GLenums are passed into methods of `gl` to specify
options. Ultimately, they're just integers. For instance, `gl.VIEWPORT` is just `2978`, and you
could use `2978` instead of `gl.VIEWPORT` if you wanted to: it's just a matter of clarity that you
shouldn't. Generally, just forget that GLenums are integers and treat them as opaque identifiers.

`gl.clear`
==========

There are only two ways to actually draw something in WebGL. One is `gl.clear`, and one is
`gl.drawArrays` or `gl.drawElements`. There are of course a bunch of other methods you'll need to
call, but the viewport won't actually change until you call one of these.

`gl.clear` is pretty simple - it sets the entire viewport to some color. Typically this is done at
the beginning of every frame of your game or animation, to start with a clean slate. The way you
should call `gl.clear` is like this:

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

You don't need `gl.DEPTH_BUFFER_BIT` in there if you're not using the depth buffer, which we're not
yet, but it doesn't hurt to get in the habit of clearing the depth buffer as well. We'll be
discussing depth in lesson 04. But you can just clear the color buffer if you prefer for now.

`gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT` is a rare instance where you actually do any operations
with a GLenum, in this case bitwise or.

Setting the clear color
=======================

Colors in WebGL are represented by 4 values that range from 0 to 1, corresponding to the red, green,
blue, and alpha channels. This is similar to CSS colors like `rgba(255, 127, 0, 1)`, except the
range is 0 to 1 instead of 0 to 255. (If you're not familiar with the idea of treating colors as
sets of rgba components, you should probably learn it, as it's the only way to deal with colors in
WebGL.) Sometimes WebGL converts between the two ranges, like when you upload a texture, but when
you just specify a color, it will generally use values 0 to 1.

	gl.clearColor(0, 0, 0, 1)

This sets the clear color to solid (opaque) black. The default is transparent black (0, 0, 0, 0).
For reasons I'll cover in lesson 04, I recommend always setting the alpha value of the clear color
to 1 in WebGL. After calling `gl.clearColor`, any calls to `gl.clear` will use the specified color.

Scissor testing
===============

The scissor test lets you update part of the viewport while leaving the rest unchanged. If you
were to draw a shape, only the part of the shape that falls within the scissor region (i.e. the part
that passes the scissor test) would appear. This is similar to the HTML5 2d drawing context method
`clip`, except it only lets you clip within a rectangular region.

	gl.enable(gl.SCISSOR_TEST)
	gl.scissor(x, y, w, h)

Scissor testing is disabled by default, so you need to enable it with `gl.enable` before it will
work. You also need to set the scissor region you want to clip within. The scissor region is in
viewport coordinates. (x,y) is the lower left corner of the scissor box in pixels, and (w,h) is the
scissor box size in pixels.

![scissor region](/lessons/img/scissor-region.png?raw=true "when scissor testing is enabled, objects drawn are clipped to the scissor region")

To disable the scissor test, use:

	gl.disable(gl.SCISSOR_TEST)

In Lesson 01, we use the scissor test along with `gl.clear` to draw rectangles of a solid color.
Scissor testing can be occasionally useful, but we're rarely going to use it.

Getters used in this lesson
===========================

	// Number: viewport width in pixels
	gl.drawingBufferWidth
	// Number: viewport height in pixels
	gl.drawingBufferHeight
	// Array of 4 Numbers: [x, y, w, h] of the viewport box
	gl.getParameter(gl.VIEWPORT)
	// Array of 4 Numbers: [r, g, b, a] of the clear color
	gl.getParameter(gl.COLOR_CLEAR_VALUE)
	// boolean: whether scissor test is enabled
	gl.getParameter(gl.SCISSOR_TEST)
	// Array of 4 Numbers: [x, y, w, h] of the scissor region
	gl.getParameter(gl.SCISSOR_BOX)

Exercises
=========

1. What number is the GLenum `gl.SCISSOR_TEST` equal to?
1. What GLenum is equal to `4354`? Hint: `for (var s in gl)`.
1. Change the background to a brighter shade of blue.
1. Move the red box so that it's a few pixels away from the upper right corner.
1. Resize the yellow box so that it's twice as tall as it is wide.
1. Change the yellow box to purple.
1. Resize the viewport to 100x100 and draw a red box inside it.
1. Add a CSS border to the canvas with `gl.canvas.style.border`.
1. Create a second viewport with its own GL context. Clear the second viweport to black, then clear
the first viewport to orange.

