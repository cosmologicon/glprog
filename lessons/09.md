attributes can only be float types
attributes are only accessible by the vertex shader
varyings can be used to pass attributes on to the fragment shader
attributes have generic values




This is the drawing command to draw 100 points:

	gl.drawArrays(gl.POINTS, 0, 100)

When this command is run, 100 instances of the vertex shader are kicked off, one for each point. If
the shader only contains uniform variables, then all 100 instances are going to have the exact same
input, and therefore the exact same output. Attributes are how different instances of the vertex
shader get values that are different for the different points.

Attributes are similar to uniforms in some ways. However, they can only have float types (`float`,
`vec*`, and `mat*`), no booleans, integers, arrays, or data structs. And they're only available in
the vertex shader. The fragment shader can't use attributes. (They're also called vertex attributes
for this reason.)

Matrix attributes are difficult to work with. A `mat3` (3x3 matrix) attribute needs to be treated
like three `vec3` attributes, one for each column of the matrix, and you need to specify them
separately. You're generally better off if you can you use uniforms for any matrices you need.



To get attributes that vary between shader instances, you need to enable array access for that
attribute, and point it to a buffer of data that has been passed into WebGL.

If you have an attribute that has not had array access enabled, it behaves more or less like a
uniform. In this case, it takes a fallback value within the shader that can be set similarly to a
uniform. The methods to set these fallback values are `gl.vertexAttrib*`, like the corresponding
`gl.uniform*` function for setting uniforms.

I don't recommend doing this very often. Usually, if you want your attributes to have a single
value, it's easier to just enable access to an array that has the same value repeated. But this
lesson includes examples of how it can be done if you want.




A buffer object (or vertex buffer object, or VBO) is an array of data that has been uploaded to
WebGL, which attributes can access.

To load data from JavaScript to WebGL, you need to use Typed Arrays. These are JavaScript objects
that have some similarlities with JavaScript Arrays, but they are a fixed length, and they can only
hold one type of data. I generally recommend sticking with `Float32Array` objects, since those
correspond to JavaScript Numbers, but there are also `Uint8Array`, `Int32Array`, and `Float64Array`
objects, among others. It's even possible to load more than one type of data into a single buffer,
but this is an advanced optimization I won't cover.

The simplest way to load data into a buffer is to get all your data as Numbers in a JavaScript
Array, use the `Float32Array` constructor to make a Typed Array object, and then load that into
the buffer.

	var array = new Float32Array(data)  // data is an Array of Numbers
	var buffer = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
	gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW)

Similiarly to when we were working with textures, you need to bind the buffer object, and then call
`gl.bufferData`, which acts on the currently bound object.



