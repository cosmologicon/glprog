<!DOCTYPE html>
<body>
<p>A 5x5 grid of points with various colors and positions. (Actually a 5x5x5 cube of points, but we
can't tell yet.)
<script src="util.js"></script>
<script type="x-shader/x-vertex" id="vsource">
// Indices specifying the point's position within the cube.
// Runs from (-2, -2, -2) in one corner of the cube to (2, 2, 2) in the opposite corner.
uniform mediump ivec3 index;

// Viewport size in pixels.
const vec3 viewportsize = vec3(854.0, 480.0, 854.0);
// Pixels per game unit.
const float gamescale = viewportsize.y / 8.0;

// Base size of points.
const float pointsize = 50.0;
void main() {
	// Convert index to a floating-point vector.
	vec3 gamepos = vec3(index);
	// Transform into view coordinates (pixels going from (0, 0, 0) to (854, 480, 480)).
	vec3 viewpos = viewportsize * 0.5 + gamepos * gamescale;

	// Scale from view coordinates to clip coordinates.
	// Points appear if each of their clip coordinates are in the range [-1, 1].
	vec3 clippos = viewpos / viewportsize * 2.0 - 1.0;
	gl_Position = vec4(clippos, 1.0);

	gl_PointSize = pointsize;
}
</script>
<script type="x-shader/x-fragment" id="fsource">
precision mediump float;

// Indices running -2 through 2 specifying the point's position within the cube.
uniform ivec3 index;

void main() {
	// Base color of this point.
	vec3 color = 0.5 + vec3(index) / 6.0;
	gl_FragColor = vec4(color, 1.0);
}
</script>
<script>
var gl = util.getContext(854, 480)
gl.enable(gl.DEPTH_TEST)  // We need depth testing but we don't need blending.
var prog = util.buildProgram(gl, vsource.text, fsource.text)
gl.useProgram(prog)

function update() {
	util.clear(gl, [0, 0, 0])
	// Iterate over each of the 5x5x5 points in the grid and update the index uniform.
	for (var i = -2 ; i <= 2 ; ++i) {
		for (var j = -2 ; j <= 2 ; ++j) {
			for (var k = -2 ; k <= 2 ; ++k) {
				util.setUniforms(gl, {index: [i, j, k]})
				util.drawPoint(gl)
			}
		}
	}
}
setInterval(update, 1000 / 60)

</script>

