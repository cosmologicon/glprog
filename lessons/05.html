<!DOCTYPE html>
<body>
<p>A 5x5x5 rotating cube of points with various colors and positions. The points are circular with
smooth edges and lightining from the top left. Black edge artifacts can be seen depending on which
points are in front.
<script src="util.js"></script>
<script type="x-shader/x-vertex" id="vsource">
uniform highp float rotation;
uniform mediump vec3 gamepos;
uniform mediump vec3 viewportsize;
uniform mediump float pointsize;

// Returns a 2x2 rotation matrix corresponding to the given angle.
mat2 R(in float angle) {
	float S = sin(angle), C = cos(angle);
	return mat2(C, S, -S, C);
}

// The amount to tilt toward the viwer, and the corresponding rotation matrix.
const highp float tilt = 0.4;
mat2 tiltmatrix = R(tilt);
void main() {
	vec3 gpos = gamepos;
	gpos.xz *= R(rotation);  // Rotate around the y (vertical) axis.
	gpos.yz *= tiltmatrix;  // Rotate around the x (horizontal) axis toward the viweer.
	mediump float gamescale = 0.3 * viewportsize.y;
	vec3 viewpos = viewportsize * 0.5 + gpos * gamescale;

	// Scale from view coordinates to clip coordinates.
	// Points appear if each of their clip coordinates are in the range [-1, 1].
	vec3 clippos = viewpos / viewportsize * 2.0 - 1.0;
	gl_Position = vec4(clippos, 1.0);

	// Make it so that points farther from the viewer are smaller.
	gl_PointSize = pointsize / (1.0 + 0.6 * clippos.z);
}
</script>
<script type="x-shader/x-fragment" id="fsource">
// Fragment shader: apply the given color, circular shape, lighting, and edge shading.
uniform mediump vec3 color;

// A unit vector pointing in the direction of the light source.
mediump vec3 lightpos = normalize(vec3(-1.0, -1.0, 1.0));
void main() {
	// r is a unit vector pointing out from the center of a sphere.
	// We only have the x and y position to start with (from gl_PointCoord), so we need to
	// calculate the z component using x^2 + y^2 + z^2 = 1.
	mediump vec3 r;
	r.xy = gl_PointCoord * 2.0 - 1.0;
	mediump float zsquared = 1.0 - dot(r.xy, r.xy);
	if (zsquared < 0.0) discard;  // Fragment is outside the circle.
	r.z = sqrt(zsquared);

	// edgefade is a factor between 0 and 1, depending on r.z, which is 0 at the edge.
	// smoothstep here means that edgefade = 0 when r.z <= 0, and edgefade = 1 when r.z >= 0.25,
	// and it's smoothly interpolated between 0 and 1 when 0 < r.z < 0.25.
	mediump float edgefade = smoothstep(0.0, 0.25, r.z);
	//edgefade = 1.0;  // Uncomment this to disable edge smoothing.

	// Lighting. shade is a factor related to the unit vector r.
	mediump float shade = 0.4 + 0.6 * dot(r, lightpos);
	shade = clamp(shade, 0.0, 1.0);  // Restrict shade to the range [0, 1].
	//shade = 1.0;  // Uncomment to disable lighting.

	gl_FragColor = vec4(color * shade, edgefade);
}
</script>
<script>
var tau = 2 * Math.PI

var gl = util.getContext(854, 480)
util.clear(gl, [0, 0, 0])
gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, 0, 1)
gl.enable(gl.BLEND)
gl.enable(gl.DEPTH_TEST)

var prog = util.buildProgram(gl, vsource.text, fsource.text)
gl.useProgram(prog)
util.setUniformv(gl, "viewportsize", [854, 480, 1000])
util.setUniform(gl, "pointsize", 50)

function update() {
	util.clear(gl, [0, 0, 0])
	var theta = 0.3 * 0.001 * Date.now() % tau
	util.setUniform(gl, "rotation", theta)
	for (var i = 0 ; i < 5 ; ++i) {
		for (var j = 0 ; j < 5 ; ++j) {
			for (var k = 0 ; k < 5 ; ++k) {
				var x = (i - 2) / 2, y = (j - 2) / 2, z = (k - 2) / 2
				var r = (i + 1) / 5, g = (j + 1) / 5, b = (k + 1) / 5
				util.drawPoint(gl, {gamepos: [x, y, z], color: [r, g, b]})
			}
		}
	}
}
setInterval(update, 1000 / 60)

</script>

