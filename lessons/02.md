# Lesson 02

Shaders and programs
====================

A shader is a subprogram of a WebGL program. Two shaders - a vertex shader and a fragment shader -
are joined together to make a WebGL program. (Other OpenGL versions can have different setups, but
every WebGL program is exactly one vertex shader and one fragment shader.)

Vertex shaders generally handle geometry, and fragment shaders generally handle colors. The name is
a bit of a misnomer: shading is just one of many things that shaders handle. Don't worry about how
they work yet. We'll cover that in the next several lessons.

This lesson covers all the steps involved in WebGL program creation:

* `gl.createShader`: create the shaders.
* `gl.shaderSource`: set the shader source code.
* `gl.compileShader`: compile the shaders.
* `gl.createProgram`: create the program.
* `gl.attachShader`: attach the shaders to the program.
* `gl.linkProgram`: link the program with the attached shaders.

If you think this method is needlessly complicated, you're right. It's like this because of how
older versions of OpenGL operated. You should feel free to use a function that takes care of the
details. But we'll cover them in this lesson.

Setting up the shaders
======================

Here's how to create a vertex shader object, set its source code, and compile it:

	var vshader = gl.createShader(gl.VERTEX_SHADER)
	gl.shaderSource(vshader, vsource)
	gl.compileShader(vshader)

`vshader` is a WebGL shader object. It doesn't have any useful methods. The only thing you ever do
with it is pass it to methods of `gl`. (This is generally how WebGL objects work. All you do with
them is pass them to methods of `gl`.) `vsource` is just a string that specifies the vertex shader
source code. You can create it any way that you like. One common method is to put it in a `script`
tag and read that tag's contents.

The shader source code is written in a language called GLSL ES. At the very minimum, a vertex shader
must have a `main` function and set the value of the global variable `gl_Position`. Here's a
minimal example that's not very useful:

	void main() {
	    gl_Position = vec4(0.0);
	}

Typical shaders are, of course, much more complicated, and we'll cover them in future lessons.

Setting up the fragment shader is very similar, but you use `gl.FRAGMENT_SHADER` with
`gl.createShader`. Fragment shaders are also written in GLSL ES, but they have some differences,
including their global variables. So for instance, you can't write to `gl_Position` within your
fragment shader source. Fragment shaders also require a `main` function. You're not required to set
any global variables within your fragment shader (though you generally will if you want to do
anything useful), so a minimal fragment shader is even shorter:

	void main() {
	}

Vertex and fragment shader objects are completely different kinds of objects. One can never be used
as the other.

Shader objects can be deleted with `gl.deleteShader`. This is not generally necessary or useful.

Setting up the program
======================

Again, a WebGL program consists of two shaders, a vertex shader and a fragment shader. Once you've
complied the shaders, you need to create the program, attach the shaders to the program, and link
the program:

	var prog = gl.createProgram()
	gl.attachShader(prog, vshader)
	gl.attachShader(prog, fshader)
	gl.linkProgram(prog)

Like the shader objects, program objects don't have any methods themselves.

It is occasionally useful to attach a shader to more than one program. This is perfectly valid. A
shader may be safely deleted with `gl.deleteShader` after it's attached to a program. Doing so won't
mess up the program. Again, though, there's not much use in doing this.

Your game will probably have a few different programs, and you'll switch between them as you draw
your scene. You switch to using a program like this:

	gl.useProgram(prog)

Program objects can be deleted with `gl.deleteProgram`. This is not generally necessary or useful.

`util.buildProgram`
===================

Like I said, that's all pretty tedious. After lesson 02, I'll be using the convenience function
`util.buildProgram`. In addition to `gl`, it takes two arguments: the vertex shader source, and the
fragment shader source. It performs the six steps listed at the top: create the shaders, set the
shader source code, compile the shaders, create the program, attach the shaders to the program, and
link the program. The program object is returned.

See `02a.html` for a version of lesson 02 rewritten using `util.buildProgram`.

Debugging
=========

Shaders are hard to write, especially at first, and even harder to debug. You should be very slow
and deliberate adding new features to your shader, because it's really hard to tell what's going on.

Fortunately, GLSL is very powerful. You can often express complex concepts with just a little code.
So your shaders probably don't need to be very long.

You have a few tools to figure out what's wrong with your shaders. If anything looks wrong, you
should check the info logs for the program and for the individual shaders. These functions return
strings that you can output to the console:

	gl.getShaderInfoLog(vshader)
	gl.getShaderInfoLog(fshader)
	gl.getProgramInfoLog(prog)

Generally, if all is well, the info logs will be blank.

There's also something called program validation. I haven't found this to be useful for debugging,
but I'm sure it must help sometimes. If all else fails, go ahead and try it:

	gl.validateProgram(prog)

After running this, check the program's info log, and see whether the validation was successful with
`gl.getProgramParameter(prog, gl.VALIDATE_STATUS)`.

Getters used in this lesson
===========================

	// boolean: whether this is a WebGL program object
	gl.isProgram(prog)
	// boolean: whether this is a WebGL shader object
	gl.isShader(shader)
	// Number: gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
	gl.getShaderParameter(shader, gl.SHADER_TYPE)
	// string: the shader's source code.
	gl.getShaderSource(shader)

	// boolean: whether the shader was successfully compiled
	gl.getShaderParameter(shader, gl.COMPILE_STATUS)
	// Number: the number of shaders attached to this program (0-2)
	gl.getProgramParameter(prog, gl.ATTACHED_SHADERS)
	// Array of objects: the shader objects attached to this program
	gl.getAttachedShaders(prog)
	// boolean: whether the program was successfully linked
	gl.getProgramParameter(prog, gl.LINK_STATUS)
	// boolean: whether the program was successfully validated
	gl.getProgramParameter(prog, gl.VALIDATE_STATUS)
	// boolean: whether the program was successfully deleted
	gl.getProgramParameter(prog, gl.DELETE_STATUS)

	// string: the shader's info log
	gl.getShaderInfoLog(vshader))
	// string: the program's info log
	gl.getProgramInfoLog(prog)

Exercises
=========

1. Try to change the shader source so that it no longer compiles. There are many possible ways to do
this.
1. Try to change the shader source so that it still compiles. There are many possible ways to do
this.
1. Create and link a second program that uses the same fragment shader object, but a different
vertex shader object.
1. What is the compiler error if you use the following for the fragment shader source?

	`"void main() { gl_FragColor = vec3(0.0); }"`

Hint: use `gl.getShaderInfoLog`.


